// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package cmd_mocks

import (
	io "io"
	os "os"
	syscall "syscall"
	testing "testing"

	cmd "github.com/grongor/go-cmd"

	mock "github.com/stretchr/testify/mock"
)

// Command is an autogenerated mock type for the Command type
type Command struct {
	mock.Mock
}

// AppendArgs provides a mock function with given fields: args
func (_m *Command) AppendArgs(args ...string) {
	_va := make([]interface{}, len(args))
	for _i := range args {
		_va[_i] = args[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AppendEnv provides a mock function with given fields: env
func (_m *Command) AppendEnv(env ...string) {
	_va := make([]interface{}, len(env))
	for _i := range env {
		_va[_i] = env[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AppendExtraFiles provides a mock function with given fields: files
func (_m *Command) AppendExtraFiles(files ...*os.File) {
	_va := make([]interface{}, len(files))
	for _i := range files {
		_va[_i] = files[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// CombinedOutput provides a mock function with given fields:
func (_m *Command) CombinedOutput() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetArgs provides a mock function with given fields:
func (_m *Command) GetArgs() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetDir provides a mock function with given fields:
func (_m *Command) GetDir() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetEnv provides a mock function with given fields:
func (_m *Command) GetEnv() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetExtraFiles provides a mock function with given fields:
func (_m *Command) GetExtraFiles() []*os.File {
	ret := _m.Called()

	var r0 []*os.File
	if rf, ok := ret.Get(0).(func() []*os.File); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*os.File)
		}
	}

	return r0
}

// GetPath provides a mock function with given fields:
func (_m *Command) GetPath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetProcess provides a mock function with given fields:
func (_m *Command) GetProcess() cmd.Process {
	ret := _m.Called()

	var r0 cmd.Process
	if rf, ok := ret.Get(0).(func() cmd.Process); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cmd.Process)
		}
	}

	return r0
}

// GetProcessState provides a mock function with given fields:
func (_m *Command) GetProcessState() cmd.ProcessState {
	ret := _m.Called()

	var r0 cmd.ProcessState
	if rf, ok := ret.Get(0).(func() cmd.ProcessState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cmd.ProcessState)
		}
	}

	return r0
}

// GetStderr provides a mock function with given fields:
func (_m *Command) GetStderr() io.Writer {
	ret := _m.Called()

	var r0 io.Writer
	if rf, ok := ret.Get(0).(func() io.Writer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Writer)
		}
	}

	return r0
}

// GetStdin provides a mock function with given fields:
func (_m *Command) GetStdin() io.Reader {
	ret := _m.Called()

	var r0 io.Reader
	if rf, ok := ret.Get(0).(func() io.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	return r0
}

// GetStdout provides a mock function with given fields:
func (_m *Command) GetStdout() io.Writer {
	ret := _m.Called()

	var r0 io.Writer
	if rf, ok := ret.Get(0).(func() io.Writer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Writer)
		}
	}

	return r0
}

// GetSysProcAttr provides a mock function with given fields:
func (_m *Command) GetSysProcAttr() *syscall.SysProcAttr {
	ret := _m.Called()

	var r0 *syscall.SysProcAttr
	if rf, ok := ret.Get(0).(func() *syscall.SysProcAttr); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*syscall.SysProcAttr)
		}
	}

	return r0
}

// Output provides a mock function with given fields:
func (_m *Command) Output() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Run provides a mock function with given fields:
func (_m *Command) Run() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetArgs provides a mock function with given fields: args
func (_m *Command) SetArgs(args []string) {
	_m.Called(args)
}

// SetDir provides a mock function with given fields: dir
func (_m *Command) SetDir(dir string) {
	_m.Called(dir)
}

// SetEnv provides a mock function with given fields: env
func (_m *Command) SetEnv(env []string) {
	_m.Called(env)
}

// SetExtraFiles provides a mock function with given fields: files
func (_m *Command) SetExtraFiles(files []*os.File) {
	_m.Called(files)
}

// SetPath provides a mock function with given fields: path
func (_m *Command) SetPath(path string) {
	_m.Called(path)
}

// SetStderr provides a mock function with given fields: writer
func (_m *Command) SetStderr(writer io.Writer) {
	_m.Called(writer)
}

// SetStdin provides a mock function with given fields: reader
func (_m *Command) SetStdin(reader io.Reader) {
	_m.Called(reader)
}

// SetStdout provides a mock function with given fields: writer
func (_m *Command) SetStdout(writer io.Writer) {
	_m.Called(writer)
}

// SetSysProcAttr provides a mock function with given fields: attributes
func (_m *Command) SetSysProcAttr(attributes *syscall.SysProcAttr) {
	_m.Called(attributes)
}

// Start provides a mock function with given fields:
func (_m *Command) Start() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StderrPipe provides a mock function with given fields:
func (_m *Command) StderrPipe() (io.ReadCloser, error) {
	ret := _m.Called()

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func() io.ReadCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StdinPipe provides a mock function with given fields:
func (_m *Command) StdinPipe() (io.WriteCloser, error) {
	ret := _m.Called()

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func() io.WriteCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StdoutPipe provides a mock function with given fields:
func (_m *Command) StdoutPipe() (io.ReadCloser, error) {
	ret := _m.Called()

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func() io.ReadCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// String provides a mock function with given fields:
func (_m *Command) String() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Wait provides a mock function with given fields:
func (_m *Command) Wait() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewCommand creates a new instance of Command. It also registers a cleanup function to assert the mocks expectations.
func NewCommand(t testing.TB) *Command {
	mock := &Command{}

	t.Cleanup(func() {
		t.Helper()
		mock.AssertExpectations(t)
	})

	return mock
}
